---
import StylizedLayout from "../../layouts/StylizedLayout.astro";

const BASE = import.meta.env.BASE_URL || '/';
---

<StylizedLayout
  title="æ´›ç©¹åçš„ä¸€å®¶è¨€ - ä»å¤¯åˆ°æ‹‰"
  description="ä¸€ä¸ªç”¨äºå¯¹å›¾åƒè¿›è¡Œæ‹–æ‹½åˆ†ç±»çš„äº¤äº’å¼é¡µé¢ã€‚"
  style={["from-pounding.css"]}
>
    <!-- å·¥å…·æ åˆ‡æ¢æŒ‰é’® -->
    <button class="sidebar-toggle" id="sidebarToggle">âš™ï¸</button>
    
    <!-- å³ä¾§å·¥å…·æ  -->
    <div class="sidebar" id="sidebar">

        <div class="tool-section">
            <h3>ğŸ“ æ›´æ”¹æ ‡é¢˜</h3>
            <input type="text" id="titleInput" placeholder="è¾“å…¥æ–°æ ‡é¢˜">
            <button id="changeTitleBtn">æ›´æ”¹æ ‡é¢˜</button>
        </div>
        
        <div class="tool-section">
            <h3>ğŸ–¼ï¸ ä¸Šä¼ å›¾ç‰‡</h3>
            <button id="uploadBtn">é€‰æ‹©å›¾ç‰‡</button>
            <input type="file" id="imageUpload" accept="image/*" multiple style="display: none;">
        </div>        
        <p>ä¸»åŒ…æ²¡æœ‰åšåŒä¸€å±‚æ¬¡ä¸‹çš„å·¦å³é¡ºåºæ’åˆ—ï¼Œåªèƒ½æŒ‰é»˜è®¤é¡ºåºæ’ï¼ŒæŠ±æ­‰å–µ</p>
    </div>
    
    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-container">
        <br><br><br>
        <h2>ä»å¤¯åˆ°æ‹‰é”è¯„â€¦â€¦</h2>
        <table id="1">
            <tr>   
                <th class="base-block first-block">å¤¯</th>
                <td class="data-block drop-zone" data-level="1"></td>
            </tr>
            <tr>
                <th class="base-block second-block">é¡¶å°–</th>
                <td class="data-block drop-zone" data-level="2"></td>
            </tr>
            <tr>
                <th class="base-block third-block">äººä¸Šäºº</th>
                <td class="data-block drop-zone" data-level="3"></td>
            </tr>
            <tr>
                <th class="base-block fourth-block">NPC</th>
                <td class="data-block drop-zone" data-level="4"></td>
            </tr>
            <tr>
                <th class="base-block fifth-block">æ‹‰å®Œäº†</th>
                <td class="data-block drop-zone" data-level="5"></td>
            </tr>
        </table>

        <div class="waiting-area" id="waitingArea">
            <h3>â³ ç­‰å¾…åŒº - æ‹–æ‹½å›¾ç‰‡åˆ°ä¸Šæ–¹è¡¨æ ¼å®Œæˆåˆ†ç±»</h3>
            <div id="imagePreview"></div>
        </div>
    </div>

<script is:inline>
    const uploadBtn = document.getElementById('uploadBtn');
    const imageUpload = document.getElementById('imageUpload');
    const imagePreview = document.getElementById('imagePreview');
    const changeTitleBtn = document.getElementById('changeTitleBtn');
    const titleInput = document.getElementById('titleInput');
    const titleH2 = document.querySelector('h2');
    const sidebarToggle = document.getElementById('sidebarToggle');
    const sidebar = document.getElementById('sidebar');
    
    // å…¨å±€å˜é‡
    let imageCount = 0;
    let waitingArea = document.getElementById('waitingArea');
    let dropZones = document.querySelectorAll('.drop-zone');
    let imagesInWaiting = new Set(); // è·Ÿè¸ªç­‰å¾…åŒºä¸­çš„å›¾ç‰‡
    let imagesInTable = new Set(); // è·Ÿè¸ªå·²åˆ†ç±»çš„å›¾ç‰‡

    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');

    // å·¥å…·æ åˆ‡æ¢åŠŸèƒ½
    sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('hidden');
        sidebarToggle.classList.remove('auto-hidden');
    });
    
    // ç§»åŠ¨ç«¯è§¦æ‘¸æ”¯æŒ
    let touchStartX = 0;
    let touchStartY = 0;
    let isSidebarOpen = false;
    
    // è§¦æ‘¸å¼€å§‹
    document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, { passive: true });
    
    // è§¦æ‘¸ç»“æŸ - å¤„ç†ä¾§æ»‘æ‰‹åŠ¿
    document.addEventListener('touchend', (e) => {
        if (!e.changedTouches[0]) return;
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // æ£€æµ‹å³æ»‘æ‰‹åŠ¿ï¼ˆä»å±å¹•å³è¾¹ç¼˜å¼€å§‹ï¼‰
        if (touchStartX > window.innerWidth - 50 && deltaX < -50 && Math.abs(deltaY) < 100) {
            sidebar.classList.remove('hidden');
            isSidebarOpen = true;
        }
        // æ£€æµ‹å·¦æ»‘æ‰‹åŠ¿å…³é—­ä¾§è¾¹æ 
        else if (isSidebarOpen && deltaX < -50 && Math.abs(deltaY) < 100) {
            sidebar.classList.add('hidden');
            isSidebarOpen = false;
        }
    }, { passive: true });
    
    // ç›‘å¬ä¾§è¾¹æ çŠ¶æ€å˜åŒ–
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.attributeName === 'class') {
                isSidebarOpen = !sidebar.classList.contains('hidden');
            }
        });
    });
    observer.observe(sidebar, { attributes: true });

    themeToggle.addEventListener('change', () => {
        applyTheme(themeToggle.checked ? 'dark' : 'light');
    });

    window.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else if (prefersDark.matches) {
            applyTheme('dark');
        } else {
            applyTheme('light');
        }
    });

    const handleSystemThemeChange = (event) => {
        const savedTheme = localStorage.getItem('theme');
        if (!savedTheme) {
            applyTheme(event.matches ? 'dark' : 'light');
        }
    };

    if (typeof prefersDark.addEventListener === 'function') {
        prefersDark.addEventListener('change', handleSystemThemeChange);
    } else if (typeof prefersDark.addListener === 'function') {
        prefersDark.addListener(handleSystemThemeChange);
    }

    uploadBtn.addEventListener('click', () => {
        imageUpload.click();
    });

    changeTitleBtn.addEventListener('click', () => {
        if (titleInput.value.trim()) {
            titleH2.textContent = titleInput.value;
            titleInput.value = '';
        }
    });

    imageUpload.addEventListener('change', (event) => {
        const files = event.target.files;
        for (let file of files) {
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.style.position = 'relative';
                    img.addEventListener('mousedown', startDrag);
                    img.addEventListener('touchstart', startTouchDrag, { passive: false });
                    img.addEventListener('dragstart', (e) => e.preventDefault()); // é˜²æ­¢é»˜è®¤æ‹–æ‹½
                    
                    // æ·»åŠ åˆ°ç­‰å¾…åŒº
                    imagesInWaiting.add(img);
                    imagePreview.appendChild(img);
                    imageCount++;
                    
                    // æ›´æ–°ç­‰å¾…åŒºæ’åˆ—
                    updateWaitingArea();
                };
                reader.readAsDataURL(file);
            }
        }
    });

    let draggedElement = null;
    let offsetX, offsetY;
    let isDragging = false;

    function startDrag(e) {
        draggedElement = e.target;
        const rect = draggedElement.getBoundingClientRect();
        
        // è®¡ç®—ç›¸å¯¹äºé¼ æ ‡çš„åç§»é‡
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        
        // è®¾ç½®å›ºå®šå®šä½ï¼Œç›¸å¯¹äºè§†å£
        draggedElement.style.position = 'fixed';
        draggedElement.style.left = rect.left + 'px';
        draggedElement.style.top = rect.top + 'px';
        draggedElement.style.zIndex = '1000';
        draggedElement.style.pointerEvents = 'none'; // é˜²æ­¢æ‹–æ‹½æ—¶è§¦å‘å…¶ä»–äº‹ä»¶
        draggedElement.classList.add('dragging');
        isDragging = true;
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
        e.preventDefault();
        e.stopPropagation();
    }

    function startTouchDrag(e) {
        if (e.touches.length !== 1) return;
        draggedElement = e.target;
        const rect = draggedElement.getBoundingClientRect();
        
        // è®¡ç®—ç›¸å¯¹äºè§¦æ‘¸ç‚¹çš„åç§»é‡
        offsetX = e.touches[0].clientX - rect.left;
        offsetY = e.touches[0].clientY - rect.top;
        
        // è®¾ç½®å›ºå®šå®šä½ï¼Œç›¸å¯¹äºè§†å£
        draggedElement.style.position = 'fixed';
        draggedElement.style.left = rect.left + 'px';
        draggedElement.style.top = rect.top + 'px';
        draggedElement.style.zIndex = '1000';
        draggedElement.style.pointerEvents = 'none'; // é˜²æ­¢æ‹–æ‹½æ—¶è§¦å‘å…¶ä»–äº‹ä»¶
        draggedElement.classList.add('dragging');
        isDragging = true;
        document.addEventListener('touchmove', touchDrag, { passive: false });
        document.addEventListener('touchend', stopDrag);
        e.preventDefault();
        e.stopPropagation();
    }

    function drag(e) {
        if (draggedElement && isDragging) {
            // è®¡ç®—ç›¸å¯¹äºè§†å£çš„ä½ç½®
            const newX = e.clientX - offsetX;
            const newY = e.clientY - offsetY;
            
            // è®¾ç½®ç»å¯¹å®šä½ï¼Œç›¸å¯¹äºè§†å£
            draggedElement.style.position = 'fixed';
            draggedElement.style.left = newX + 'px';
            draggedElement.style.top = newY + 'px';
            draggedElement.style.zIndex = '1000';
            
            // è·å–å›¾ç‰‡ä¸­å¿ƒç‚¹
            const imgRect = draggedElement.getBoundingClientRect();
            const imgCenterX = imgRect.left + imgRect.width / 2;
            const imgCenterY = imgRect.top + imgRect.height / 2;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨è¡¨æ ¼åŒºåŸŸä¸Šæ–¹ï¼Œæä¾›è§†è§‰åé¦ˆ
            const tableRect = document.querySelector('table').getBoundingClientRect();
            
            // æ¸…é™¤æ‰€æœ‰drop-zoneçš„é«˜äº®
            dropZones.forEach(zone => zone.classList.remove('drag-over'));
            
            // å¦‚æœåœ¨è¡¨æ ¼åŒºåŸŸå†…ï¼Œé«˜äº®æœ€è¿‘çš„drop-zone
            if (imgCenterX >= tableRect.left && 
                imgCenterX <= tableRect.right && 
                imgCenterY >= tableRect.top && 
                imgCenterY <= tableRect.bottom) {
                
                const closestZone = findClosestDropZoneByCenter(imgCenterX, imgCenterY);
                if (closestZone) {
                    closestZone.classList.add('drag-over');
                }
            }
        }
    }

    function touchDrag(e) {
        if (draggedElement && isDragging && e.touches.length === 1) {
            e.preventDefault();
            
            // è®¡ç®—ç›¸å¯¹äºè§†å£çš„ä½ç½®
            const newX = e.touches[0].clientX - offsetX;
            const newY = e.touches[0].clientY - offsetY;
            
            // è®¾ç½®ç»å¯¹å®šä½ï¼Œç›¸å¯¹äºè§†å£
            draggedElement.style.position = 'fixed';
            draggedElement.style.left = newX + 'px';
            draggedElement.style.top = newY + 'px';
            draggedElement.style.zIndex = '1000';
        }
    }

    function stopDrag() {
        if (draggedElement) {
            draggedElement.style.zIndex = '1';
            draggedElement.style.pointerEvents = 'auto'; // æ¢å¤äº‹ä»¶å¤„ç†
            draggedElement.classList.remove('dragging');
            
            // æ¸…é™¤æ‰€æœ‰drop-zoneçš„é«˜äº®
            dropZones.forEach(zone => zone.classList.remove('drag-over'));
            
            // è·å–å›¾ç‰‡ä¸­å¿ƒç‚¹
            const imgRect = draggedElement.getBoundingClientRect();
            const imgCenterX = imgRect.left + imgRect.width / 2;
            const imgCenterY = imgRect.top + imgRect.height / 2;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨è¡¨æ ¼åŒºåŸŸå†…
            const tableRect = document.querySelector('table').getBoundingClientRect();
            if (imgCenterX >= tableRect.left && 
                imgCenterX <= tableRect.right && 
                imgCenterY >= tableRect.top && 
                imgCenterY <= tableRect.bottom) {
                
                // æ‰¾åˆ°æœ€è¿‘çš„drop-zone
                const closestDropZone = findClosestDropZoneByCenter(imgCenterX, imgCenterY);
                if (closestDropZone) {
                    // å¦‚æœå›¾ç‰‡å·²ç»åœ¨è¡¨æ ¼ä¸­ï¼Œæ£€æŸ¥æ˜¯å¦ç§»åŠ¨åˆ°ä¸åŒçš„drop-zone
                    const currentDropZone = draggedElement.closest('.drop-zone');
                    if (currentDropZone && currentDropZone !== closestDropZone) {
                        // ç§»åŠ¨åˆ°ä¸åŒçš„drop-zone
                        moveImageToTable(draggedElement, closestDropZone);
                    } else if (!currentDropZone) {
                        // ä»ç­‰å¾…åŒºç§»åŠ¨åˆ°è¡¨æ ¼
                        moveImageToTable(draggedElement, closestDropZone);
                    } else {
                        // å›åˆ°åŸä½ç½®
                        resetImagePosition(draggedElement);
                    }
                } else {
                    // å›åˆ°åŸä½ç½®
                    resetImagePosition(draggedElement);
                }
            } else {
                // æ£€æŸ¥æ˜¯å¦æ‹–æ‹½åˆ°ç­‰å¾…åŒº
                const waitingRect = waitingArea.getBoundingClientRect();
                if (imgCenterX >= waitingRect.left && 
                    imgCenterX <= waitingRect.right && 
                    imgCenterY >= waitingRect.top && 
                    imgCenterY <= waitingRect.bottom) {
                    // ç§»åŠ¨åˆ°ç­‰å¾…åŒº
                    moveImageToWaiting(draggedElement);
                } else {
                    // å¦‚æœæ‹–æ‹½åˆ°æ— æ•ˆåŒºåŸŸï¼Œå›åˆ°åŸä½ç½®
                    resetImagePosition(draggedElement);
                }
            }
            
            draggedElement = null;
        }
        isDragging = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', touchDrag);
        document.removeEventListener('touchend', stopDrag);
    }
    
    // æ‰¾åˆ°æœ€è¿‘çš„drop-zone
    function findClosestDropZone(img) {
        const imgRect = img.getBoundingClientRect();
        let closestZone = null;
        let minDistance = Infinity;
        
        dropZones.forEach(zone => {
            const zoneRect = zone.getBoundingClientRect();
            const distance = Math.sqrt(
                Math.pow(imgRect.left - zoneRect.left, 2) + 
                Math.pow(imgRect.top - zoneRect.top, 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestZone = zone;
            }
        });
        
        return closestZone;
    }
    
    // æ ¹æ®ä¸­å¿ƒç‚¹æ‰¾åˆ°æœ€è¿‘çš„drop-zone
    function findClosestDropZoneByCenter(centerX, centerY) {
        let closestZone = null;
        let minDistance = Infinity;
        
        dropZones.forEach(zone => {
            const zoneRect = zone.getBoundingClientRect();
            const zoneCenterX = zoneRect.left + zoneRect.width / 2;
            const zoneCenterY = zoneRect.top + zoneRect.height / 2;
            
            const distance = Math.sqrt(
                Math.pow(centerX - zoneCenterX, 2) + 
                Math.pow(centerY - zoneCenterY, 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestZone = zone;
            }
        });
        
        return closestZone;
    }
    
    // é‡ç½®å›¾ç‰‡ä½ç½®
    function resetImagePosition(img) {
        // é‡ç½®å›¾ç‰‡æ ·å¼
        img.style.position = 'relative';
        img.style.left = 'auto';
        img.style.top = 'auto';
        img.style.zIndex = '1';
        img.style.pointerEvents = 'auto';
    }
    
    // ç§»åŠ¨å›¾ç‰‡åˆ°è¡¨æ ¼
    function moveImageToTable(img, dropZone) {
        // è®°å½•åŸå§‹ä½ç½®
        const originalParent = img.parentNode;
        const originalNextSibling = img.nextSibling;
        
        // ä»ç­‰å¾…åŒºç§»é™¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (imagesInWaiting.has(img)) {
            imagesInWaiting.delete(img);
        }
        
        // æ·»åŠ åˆ°è¡¨æ ¼
        imagesInTable.add(img);
        dropZone.appendChild(img);
        dropZone.classList.add('has-image');
        
        // é‡ç½®å›¾ç‰‡æ ·å¼
        img.style.position = 'relative';
        img.style.left = 'auto';
        img.style.top = 'auto';
        img.style.zIndex = '1';
        img.style.pointerEvents = 'auto';
        
        // ä¸ºè¡¨æ ¼ä¸­çš„å›¾ç‰‡æ·»åŠ æ‹–æ‹½äº‹ä»¶ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
        if (!img.hasAttribute('data-drag-events-added')) {
            img.addEventListener('mousedown', startDrag);
            img.addEventListener('touchstart', startTouchDrag, { passive: false });
            img.addEventListener('dragstart', (e) => e.preventDefault());
            img.setAttribute('data-drag-events-added', 'true');
        }
        
        // æ›´æ–°ç­‰å¾…åŒºå’Œè¡¨æ ¼è¡Œé«˜
        updateWaitingArea();
        updateTableRowHeights();
    }
    
    // ç§»åŠ¨å›¾ç‰‡å›ç­‰å¾…åŒº
    function moveImageToWaiting(img) {
        // ä»è¡¨æ ¼ç§»é™¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (imagesInTable.has(img)) {
            imagesInTable.delete(img);
        }
        
        // æ·»åŠ åˆ°ç­‰å¾…åŒº
        imagesInWaiting.add(img);
        imagePreview.appendChild(img);
        
        // é‡ç½®å›¾ç‰‡æ ·å¼
        img.style.position = 'static';
        img.style.left = 'auto';
        img.style.top = 'auto';
        img.style.zIndex = '1';
        img.style.pointerEvents = 'auto';
        
        // æ›´æ–°ç­‰å¾…åŒºå’Œè¡¨æ ¼è¡Œé«˜
        updateWaitingArea();
        updateTableRowHeights();
    }
    
    // æ›´æ–°ç­‰å¾…åŒºæ’åˆ—
    function updateWaitingArea() {
        const waitingImages = Array.from(imagesInWaiting);
        if (waitingImages.length === 0) {
            waitingArea.style.display = 'none';
            return;
        }
        
        waitingArea.style.display = 'block';
        
        // é‡ç½®æ‰€æœ‰å›¾ç‰‡çš„å®šä½ï¼Œè®©CSS Gridè‡ªåŠ¨æ’åˆ—
        waitingImages.forEach((img) => {
            img.style.position = 'static';
            img.style.left = 'auto';
            img.style.top = 'auto';
        });
        
        // è°ƒæ•´ç­‰å¾…åŒºé«˜åº¦
        const totalRows = Math.ceil(waitingImages.length / Math.floor(imagePreview.offsetWidth / 135)); // æ ¹æ®å®¹å™¨å®½åº¦è®¡ç®—æ¯è¡Œæ•°é‡
        waitingArea.style.minHeight = (totalRows * 120) + 'px';
    }
    
    // æ›´æ–°è¡¨æ ¼è¡Œé«˜
    function updateTableRowHeights() {
        dropZones.forEach(zone => {
            const images = zone.querySelectorAll('img');
            if (images.length === 0) {
                zone.style.minHeight = '120px';
                zone.classList.remove('has-image');
            } else {
                // è®¡ç®—æ¯è¡Œå¯ä»¥æ”¾ç½®çš„å›¾ç‰‡æ•°é‡ï¼ˆè€ƒè™‘å®¹å™¨å®½åº¦å’Œå›¾ç‰‡å°ºå¯¸ï¼‰
                const zoneWidth = zone.offsetWidth;
                const imageWidth = 100; // å›¾ç‰‡å®½åº¦
                const gap = 10; // å›¾ç‰‡é—´è·
                const padding = 20; // å®¹å™¨å†…è¾¹è·
                
                const availableWidth = zoneWidth;
                const imagesPerRow = Math.floor(availableWidth / (imageWidth));
                const actualImagesPerRow = Math.max(1, imagesPerRow) + 1;
                
                // è®¡ç®—éœ€è¦çš„è¡Œæ•°
                const rows = Math.ceil(images.length / actualImagesPerRow);
                
                // è®¡ç®—é«˜åº¦ï¼šå›¾ç‰‡é«˜åº¦ + é—´è· + å†…è¾¹è·
                const imageHeight = 100;
                const rowGap = 10;
                const newHeight = Math.max(120, rows * (imageHeight + rowGap) + 20);
                
                zone.style.minHeight = newHeight + 'px';
                zone.classList.add('has-image');
            }
        });
    }
    
    // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—è¡Œé«˜
    window.addEventListener('resize', () => {
        setTimeout(() => {
            updateTableRowHeights();
            updateWaitingArea();
        }, 100);
    });
    
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–è¡Œé«˜
    window.addEventListener('load', () => {
        setTimeout(() => {
            updateTableRowHeights();
        }, 100);
    });
</script>


</StylizedLayout>